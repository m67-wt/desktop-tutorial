<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: monospace; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c")
const ctx = canvas.getContext("2d")

let zBuffer = []
let gameState = "playing"

function resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    ctx.imageSmoothingEnabled = false
}
window.addEventListener("resize", resize)
resize()

const TILE = 64
const TEXTURE_SIZE = 500

const map = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,4,3],
    [2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,3],
    [2,0,0,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,4],
    [2,0,0,5,0,0,0,0,0,0,5,0,0,0,0,0,0,2,0,1,0,1,1,1,5,1,1,1,1,5,1,1,4,0,0,0,3],
    [2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,4],
    [0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,1,0,1,1,0,0,0,0,1,0,0,0,1,3,4,4,3,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,3,3,0,3,3,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,3,0,0,0,0,3,3,3,3,3,3,3,4,0,0,0,0,3,0,0,4],
    [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,5,0,0,0,0,0,5,0,0,0,0,0,0,7,0,3,3,0,3,3,0,4],
    [0,0,0,0,0,2,2,2,2,2,2,0,0,3,0,3,0,2,3,0,0,0,0,3,3,3,0,3,3,3,4,0,0,0,0,0,0,0,4],
    [0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,2,3,3,5,3,3,3,0,3,0,3,0,0,4,0,3,3,0,3,3,0,4],
    [0,0,0,0,0,2,0,2,2,2,2,0,0,3,0,3,0,2,0,4,0,4,0,0,0,3,0,3,0,0,4,0,0,0,0,0,0,0,4],
    [0,0,0,0,0,2,0,2,0,0,2,2,2,2,2,2,2,2,0,4,0,4,0,0,0,2,0,2,0,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,4,0,4,0,0,0,2,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,0,5,0,0,0,0,0,0,0,0,1,0,0,4,0,4,0,0,0,2,0,2,0,2,6,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,4,0,4,0,0,0,2,0,2,2,2,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,3,1,3,0,1,1,1,0,0,0,0,0,0,0,4,4,4,0,4,4,4,4,2,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0],
    [0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,2,2,2,0,0,2,0,0,0,0,0,0,0,0],
    [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,4,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,8,0,0,0,0,0,2,0,0,0,0,0,0,0,0],
    [1,1,5,1,0,0,0,0,0,0,0,0,0,0,0,0,1,3,4,4,4,3,1,4,4,4,4,5,4,4,4,4,0,0,0,0,0,0,5,0,0,0,0,0,2,2,2,2,0,0,2,0,0,0,0,0,0,0,0],
    [1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,3,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,0,0,0],
    [3,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,4,4,0,3,0,3,0,3,0,4,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,3,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,3,4,4,4,3,1,4,0,3,0,3,0,3,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,3,0,3,0,3,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4]
]

function loadImg(src) {
    const img = new Image()
    img.src = src
    return img
}

const wallTextures = {
    1: loadImg("assets/wall textures-1.png"),
    2: loadImg("assets/wall textures-2.png"),
    3: loadImg("assets/wall textures-3.png"),
    4: loadImg("assets/wall textures-4.png"),
    "5_closed": loadImg("assets/wall_texture_door-1.png"),
    "5_open":   loadImg("assets/wall_texture_door_open-2.png"),
    "6_closed": loadImg("assets/wall_texture_silver_door-1.png"),
    "6_open":   loadImg("assets/wall_texture_silver_door_open-2.png"),
    "7_closed": loadImg("assets/wall_texture_gold_door-3.png"),
    "7_open":   loadImg("assets/wall_texture_gold_door_open-4.png"),
    "8_closed": loadImg("assets/wall_texture_ruby_door-5.png"),
    "8_open":   loadImg("assets/wall_texture_ruby_door_open-6.png")
}

const explosionSheet = loadImg("assets/enemy_exploder.png")

const sprites = [
    { x: TILE * 21.5, y: TILE * 21.5, texture: loadImg("assets/wall textures-5.png"), type: 'gold', collected: false },
    { x: TILE * 29.5, y: TILE * 4.5, texture: loadImg("assets/silver_key-2.png"), type: 'silver', collected: false },
    { x: TILE * 37.5, y: TILE * 8.5, texture: loadImg("assets/ruby_key-1.png"), type: 'ruby', collected: false },
    { x: TILE * 8.5, y: TILE * 3.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 30.5, y: TILE * 4.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 19.5, y: TILE * 21.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 42.5, y: TILE * 19.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 21.5, y: TILE * 8.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 35.5, y: TILE * 3.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 27.5, y: TILE * 23.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 49.5, y: TILE * 15.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 14.5, y: TILE * 14.0, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 27.5, y: TILE * 21.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 29.5, y: TILE * 13.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 27.5, y: TILE * 8.5, texture: loadImg("assets/enemy_melee-1.png"), type: 'enemy', health: 2, lastAttack: 0, speed: 1.0 },
    { x: TILE * 9.5, y: TILE * 4.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
    { x: TILE * 35.5, y: TILE * 11.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
    { x: TILE * 35.5, y: TILE * 7.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
    { x: TILE * 20.5, y: TILE * 21.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
    { x: TILE * 1.5, y: TILE * 21.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
    { x: TILE * 41.5, y: TILE * 21.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
    { x: TILE * 36.5, y: TILE * 3.5, texture: loadImg("assets/enemy_exploder-1.png"), type: 'exploder', health: 1, speed: 2.0, state: 'chase', timer: 0, frame: 0 },
]

const openDoors = {}
const reloadSheet = loadImg("assets/gun_reloading.png")
const fireSheet = loadImg("assets/gun_fire.png")
const faceSheet = loadImg("assets/charater_hurt_models.png")

const ANIMS = {
    idle:   { frames: [0], sheet: reloadSheet, count: 21, speed: 125 },
    fire:   { frames: [0, 1, 2, 3, 4], sheet: fireSheet, count: 5, speed: 166 }, 
    reload: { frames: Array.from({length: 21}, (_, i) => i), sheet: reloadSheet, count: 21, speed: 125 }
}

const weapon = { ammo: 1, state: "idle", frame: 0, lastFrameUpdate: 0, animSpeed: 125 }
const player = { x: TILE * 2.5, y: TILE * 2.5, angle: 0, move: 2.5, rot: 0.05, hp: 100, inventory: { gold: false, silver: false, ruby: false }, lastDmgTime: 0, lastRegenTime: 0 }
const keys = {}

window.addEventListener("keydown", e => {
    const k = e.key.toLowerCase()
    keys[k] = true
    if (gameState !== "playing") { location.reload(); return }
    if (k === " ") handleAction()
    if (k === "r") reload()
    if (k === "e") tryOpenDoor()
})
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false)
window.addEventListener("mousedown", () => {
    if (gameState !== "playing") location.reload()
    else handleAction()
})

function isWall(x, y) {
    const mx = Math.floor(x / TILE)
    const my = Math.floor(y / TILE)
    if (!map[my] || map[my][mx] === undefined) return true
    
    const tile = map[my][mx]
    const doorPos = `${my},${mx}`

    if (tile === 0) return false
    
    if ([5, 6, 7, 8].includes(tile)) {
        const pmx = Math.floor(player.x / TILE)
        const pmy = Math.floor(player.y / TILE)
        if (openDoors[doorPos] || (pmx === mx && pmy === my)) return false
    }
    return tile > 0
}

function tryOpenDoor() {
    const dx = player.x + Math.cos(player.angle) * 60
    const dy = player.y + Math.sin(player.angle) * 60
    const mx = Math.floor(dx / TILE), my = Math.floor(dy / TILE)
    
    if (map[my]) {
        const tile = map[my][mx]
        const doorPos = `${my},${mx}`
        let canOpen = false

        if (tile === 5) canOpen = true
        if (tile === 6 && player.inventory.silver) canOpen = true
        if (tile === 7 && player.inventory.gold) canOpen = true
        if (tile === 8 && player.inventory.ruby) { gameState = "win"; return }

        if (canOpen && !openDoors[doorPos]) {
            openDoors[doorPos] = true
            setTimeout(() => { delete openDoors[doorPos] }, 5000)
        }
    }
}

function handleAction() {
    if (weapon.state !== "idle") return
    if (weapon.ammo > 0) shoot(); else reload()
}

function shoot() {
    weapon.ammo = 0; weapon.state = "fire"; weapon.frame = 0
    weapon.animSpeed = ANIMS.fire.speed; weapon.lastFrameUpdate = performance.now()
    
    sprites.forEach(s => {
        if ((s.type === 'enemy' || s.type === 'exploder') && s.health > 0) {
            const dx = s.x - player.x, dy = s.y - player.y
            const dist = Math.sqrt(dx*dx + dy*dy)
            let ang = Math.atan2(dy, dx) - player.angle
            while (ang < -Math.PI) ang += 2 * Math.PI
            while (ang > Math.PI) ang -= 2 * Math.PI
            
            if (Math.abs(ang) < 0.2 && dist < 600) {
                s.health--
            }
        }
    })
}

function reload() {
    if (weapon.state === "idle" && weapon.ammo === 0) {
        weapon.state = "reload"; weapon.frame = 0
        weapon.animSpeed = ANIMS.reload.speed; weapon.lastFrameUpdate = performance.now()
    }
}

function updateEnemies() {
    const now = performance.now()
    sprites.forEach(s => {
        if (s.health <= 0) return
        const dx = player.x - s.x
        const dy = player.y - s.y
        const dist = Math.sqrt(dx*dx + dy*dy)

        if (s.type === 'enemy') {
            if (dist < 320 && dist > 40) {
                const angle = Math.atan2(dy, dx)
                const nx = s.x + Math.cos(angle) * s.speed
                const ny = s.y + Math.sin(angle) * s.speed
                if (!isWall(nx, s.y)) s.x = nx
                if (!isWall(s.x, ny)) s.y = ny
            }
            if (dist <= 45 && now - s.lastAttack > 1500) {
                player.hp -= 15
                player.lastDmgTime = now
                s.lastAttack = now
                if (player.hp <= 0) { player.hp = 0; gameState = "lose" }
            }
        } else if (s.type === 'exploder') {
            if (s.state === 'chase') {
                if (dist < 400 && dist > 60) {
                    const angle = Math.atan2(dy, dx)
                    const nx = s.x + Math.cos(angle) * s.speed
                    const ny = s.y + Math.sin(angle) * s.speed
                    if (!isWall(nx, s.y)) s.x = nx
                    if (!isWall(s.x, ny)) s.y = ny
                }
                if (dist <= 64) { s.state = 'priming'; s.timer = now }
            } else if (s.state === 'priming') {
                if (now - s.timer > 2000) { s.state = 'exploding'; s.timer = now; s.texture = explosionSheet }
            } else if (s.state === 'exploding') {
                s.frame = Math.floor((now - s.timer) / 400)
                if (s.frame >= 4) {
                    if (dist <= 64) {
                        player.lastDmgTime = now
                        if (dist <= 16) player.hp = 0 
                        else if (dist <= 32) player.hp -= 128
                        else player.hp -= 50
                        if (player.hp <= 0) { player.hp = 0; gameState = "lose" }
                    }
                    s.health = 0
                }
            }
        }
    })
}

function drawCrosshair() {
    const centerX = canvas.width / 2
    const centerY = (canvas.height - 160) / 2
    const size = 10
    const gap = 5

    ctx.strokeStyle = "lime"
    ctx.lineWidth = 2

    ctx.beginPath()
    ctx.moveTo(centerX, centerY - size - gap)
    ctx.lineTo(centerX, centerY - gap)
    ctx.moveTo(centerX, centerY + gap)
    ctx.lineTo(centerX, centerY + size + gap)
    ctx.moveTo(centerX - size - gap, centerY)
    ctx.lineTo(centerX - gap, centerY)
    ctx.moveTo(centerX + gap, centerY)
    ctx.lineTo(centerX + size + gap, centerY)
    ctx.stroke()

    ctx.fillStyle = "lime"
    ctx.fillRect(centerX - 1, centerY - 1, 2, 2)
}

function update() {
    let moveStep = 0
    if (keys["w"]) moveStep = player.move
    if (keys["s"]) moveStep = -player.move
    if (keys["a"]) player.angle -= player.rot
    if (keys["d"]) player.angle += player.rot

    let nx = player.x + Math.cos(player.angle) * moveStep
    let ny = player.y + Math.sin(player.angle) * moveStep
    if (!isWall(nx, player.y)) player.x = nx
    if (!isWall(player.x, ny)) player.y = ny

    sprites.forEach(s => {
        if (s.type !== 'enemy' && s.type !== 'exploder' && !s.collected) {
            const d = Math.sqrt((player.x - s.x)**2 + (player.y - s.y)**2)
            if (d < 30) { s.collected = true; player.inventory[s.type] = true }
        }
    })

    updateEnemies()

    const now = performance.now()

    if (player.hp > 0 && player.hp < 100 && now - player.lastDmgTime > 10000) {
        if (now - player.lastRegenTime > 10000) {
            player.hp = Math.min(100, player.hp + 5)
            player.lastRegenTime = now
        }
    } else {
        player.lastRegenTime = now
    }

    const anim = ANIMS[weapon.state]
    if (weapon.state !== "idle" && now - weapon.lastFrameUpdate > weapon.animSpeed) {
        weapon.frame++
        weapon.lastFrameUpdate = now
        if (weapon.frame >= anim.frames.length) {
            if (weapon.state === "fire") { weapon.state = "reload"; weapon.frame = 0 }
            else { weapon.ammo = 1; weapon.state = "idle"; weapon.frame = 0 }
        }
    }
}

function drawWalls() {
    const fov = Math.PI / 3
    const viewH = canvas.height - 160
    zBuffer = []
    const pmx = Math.floor(player.x / TILE)
    const pmy = Math.floor(player.y / TILE)

    for (let x = 0; x < canvas.width; x++) {
        const rayAngle = player.angle - fov/2 + (x/canvas.width)*fov
        const rayCos = Math.cos(rayAngle), raySin = Math.sin(rayAngle)
        let rx = player.x, ry = player.y, dist = 0
        let hit = false

        while (dist < 1200) {
            rx += rayCos * 1.5; ry += raySin * 1.5; dist += 1.5
            let mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE)

            if (map[my] && map[my][mx] > 0) {
                if (mx === pmx && my === pmy) continue

                let tid = map[my][mx]
                let tex
                if ([5, 6, 7, 8].includes(tid)) {
                    const state = openDoors[`${my},${mx}`] ? "open" : "closed"
                    if (state === "open") continue 
                    tex = wallTextures[`${tid}_${state}`]
                } else {
                    tex = wallTextures[tid]
                }

                const corr = dist * Math.cos(rayAngle - player.angle)
                zBuffer[x] = corr
                const h = (TILE * viewH) / corr

                if (tex && tex.complete) {
                    let hitV = Math.floor((rx - rayCos * 2) / TILE) !== mx
                    let texX = Math.floor(((hitV ? ry % TILE : rx % TILE) / TILE) * TEXTURE_SIZE)
                    ctx.drawImage(tex, texX, 0, 1, TEXTURE_SIZE, x, (viewH-h)/2, 1, h)
                }
                ctx.fillStyle = `rgba(0,0,0,${Math.min(0.8, dist/800)})`
                ctx.fillRect(x, (viewH-h)/2, 1, h)
                hit = true; break
            }
        }
        if (!hit) zBuffer[x] = 1200
    }
}

function drawSprites() {
    const viewH = canvas.height - 160
    const fov = Math.PI / 3
    
    sprites.sort((a,b) => {
        const distA = Math.sqrt((a.x-player.x)**2 + (a.y-player.y)**2)
        const distB = Math.sqrt((b.x-player.x)**2 + (b.y-player.y)**2)
        return distB - distA
    })

    sprites.forEach(s => {
        if (s.collected || s.health <= 0 || !s.texture.complete) return
        const dx = s.x - player.x, dy = s.y - player.y
        const dist = Math.sqrt(dx*dx + dy*dy)
        let ang = Math.atan2(dy, dx) - player.angle
        while (ang < -Math.PI) ang += 2 * Math.PI
        while (ang > Math.PI) ang -= 2 * Math.PI
        const corr = dist * Math.cos(ang)
        if (Math.abs(ang) < fov && corr > 10) {
            const h = (TILE * viewH) / corr
            const sx = (0.5 * (ang / (fov / 2)) + 0.5) * canvas.width
            for (let i = 0; i < h; i++) {
                const cx = Math.floor(sx - h/2 + i)
                if (cx >= 0 && cx < canvas.width && zBuffer[cx] > corr) {
                    if (s.type === 'exploder' && s.state === 'exploding') {
                        const fw = 320
                        const texX = Math.floor((i/h) * fw) + (s.frame * fw)
                        ctx.drawImage(s.texture, texX, 0, 1, s.texture.height, cx, (viewH-h)/2, 1, h)
                    } else {
                        const texX = Math.floor((i/h) * s.texture.width)
                        ctx.drawImage(s.texture, texX, 0, 1, s.texture.height, cx, (viewH-h)/2, 1, h)
                    }
                }
            }
        }
    })
}

function drawWeapon() {
    const anim = ANIMS[weapon.state]
    const sheet = anim.sheet
    if (sheet.complete && sheet.width > 0) {
        const fw = sheet.width / anim.count
        const fh = sheet.height
        const dh = canvas.height * 0.7
        const dw = dh * (fw / fh)
        ctx.save()
        ctx.translate(canvas.width * 0.25, canvas.height - 160)
        ctx.rotate(15 * Math.PI / 180)
        ctx.drawImage(sheet, anim.frames[weapon.frame] * fw, 0, fw, fh, -dw * 0.1, -dh * 0.95, dw, dh)
        ctx.restore()
    }
}

function drawHUD() {
    const top = canvas.height - 160
    ctx.fillStyle = "#222"; ctx.fillRect(0, top, canvas.width, 160)
    ctx.fillStyle = "#000"; ctx.fillRect(40, top + 10, 85, 85)
    if (faceSheet.complete) ctx.drawImage(faceSheet, (player.hp >= 80 ? 0 : player.hp >= 40 ? 2 : 4)*64, 0, 64, 64, 45, top+15, 75, 75)
    
    ctx.fillStyle = "white"; ctx.font = "bold 14px monospace"
    ctx.fillText("INVENTORY:", 150, top + 35)
    if (player.inventory.silver) { ctx.fillStyle = "silver"; ctx.fillText("[SILVER KEY]", 150, top + 60) }
    if (player.inventory.gold) { ctx.fillStyle = "gold"; ctx.fillText("[GOLD KEY]", 150, top + 85) }
    if (player.inventory.ruby) { ctx.fillStyle = "#FF4444"; ctx.fillText("[RUBY KEY]", 150, top + 110) }

    ctx.fillStyle = "red"; ctx.font = "bold 16px monospace"; ctx.fillText("HEALTH", 40, top + 115)
    ctx.fillStyle = "white"; ctx.font = "bold 40px monospace"; ctx.fillText(`${player.hp}%`, 40, top + 150)
    ctx.fillStyle = "yellow"; ctx.font = "bold 16px monospace"; ctx.fillText("AMMO", canvas.width - 120, top + 40)
    ctx.fillStyle = "white"; ctx.font = "bold 30px monospace"; ctx.fillText(weapon.ammo > 0 ? "1/1" : "0/1", canvas.width - 120, top + 80)
}

function drawEndScreen(text, color) {
    ctx.fillStyle = "black"
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    ctx.textAlign = "center"
    ctx.fillStyle = color
    ctx.font = "bold 60px monospace"
    ctx.fillText(text, canvas.width/2, canvas.height/2)
    ctx.fillStyle = "white"
    ctx.font = "24px monospace"
    ctx.fillText("TRY AGAIN", canvas.width/2, canvas.height/2 + 60)
}

function loop() {
    if (gameState === "win") {
        drawEndScreen("YOU WIN", "#90EE90")
        return
    }
    if (gameState === "lose") {
        drawEndScreen("YOU LOSE", "#FF0000")
        return
    }
    update()
    const vH = canvas.height - 160
    ctx.fillStyle = "#1a1a1a"; ctx.fillRect(0, 0, canvas.width, vH/2)
    ctx.fillStyle = "#222"; ctx.fillRect(0, vH/2, canvas.width, vH/2)
    drawWalls() 
    drawSprites() 
    drawWeapon() 
    drawHUD()
    drawCrosshair()
    requestAnimationFrame(loop)
}

loop()
</script>
</body>
</html>
