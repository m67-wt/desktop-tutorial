<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>

<canvas id="c"></canvas>

<script>
/* ================= CANVAS ================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageSmoothingEnabled = false;
}
window.addEventListener("resize", resize);
resize();

/* ================= MAP ================= */
const TILE = 64;
const map = [
    [4,4,4,4,4,4,4,4,4,4,4,4],
    [4,0,0,0,0,0,0,0,0,0,0,4],
    [4,0,1,1,1,0,2,2,0,0,0,4],
    [4,0,0,0,1,0,0,0,0,3,0,4],
    [4,0,3,0,1,0,4,0,0,3,0,4],
    [4,0,0,0,0,0,4,0,0,0,0,4],
    [4,4,4,4,4,4,4,4,4,4,4,4],
];

/* ================= TEXTURES ================= */
const TEXTURE_SIZE = 500;
function loadTexture(src) {
    const img = new Image();
    img.src = src;
    return img;
}

const wallTextures = [
    null,
    loadTexture("assets/wall textures-1.png"),
    loadTexture("assets/wall textures-2.png"),
    loadTexture("assets/wall textures-3.png"),
    loadTexture("assets/wall textures-4.png")
];

/* ================= SPRITE SHEET CONFIG ================= */
const weaponSheet = new Image();
weaponSheet.src = "assets/gun_reload.png"; // Your updated filename

const SPRITE_SIZE = 64; 
const weapon = {
    ammo: 25,
    maxAmmo: 25,
    state: "idle",
    frame: 0,
    lastFrameUpdate: 0,
    animSpeed: 70, // Adjust this if the reload is too fast/slow
};

// Mapping of frames (0-indexed) from your 19-column sheet
const ANIMS = {
    idle: [0],
    fire: [1, 2, 3, 4, 5], 
    reload: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
};

/* ================= PLAYER & INPUT ================= */
const player = {
    x: TILE * 1.5,
    y: TILE * 1.5,
    angle: 0,
    move: 3.5,
    rot: 0.05
};

const keys = {};
window.addEventListener("keydown", e => {
    const k = e.key.toLowerCase();
    keys[k] = true;
    if (k === " " || k === "control") shoot();
    if (k === "r") reload();
});
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
window.addEventListener("mousedown", (e) => { if(e.button === 0) shoot(); });

/* ================= LOGIC ================= */
function isWall(x, y) {
    const mx = Math.floor(x / TILE);
    const my = Math.floor(y / TILE);
    if (!map[my] || map[my][mx] === undefined) return true;
    return map[my][mx] > 0;
}

function shoot() {
    if (weapon.state !== "idle" || weapon.ammo <= 0) return;
    weapon.ammo--;
    weapon.state = "fire";
    weapon.frame = 0;
}

function reload() {
    if (weapon.state !== "idle" || weapon.ammo === weapon.maxAmmo) return;
    weapon.state = "reload";
    weapon.frame = 0;
}

function update() {
    // Movement
    let moveX = 0, moveY = 0;
    if (keys["w"]) {
        moveX += Math.cos(player.angle) * player.move;
        moveY += Math.sin(player.angle) * player.move;
    }
    if (keys["s"]) {
        moveX -= Math.cos(player.angle) * player.move;
        moveY -= Math.sin(player.angle) * player.move;
    }
    if (keys["a"]) player.angle -= player.rot;
    if (keys["d"]) player.angle += player.rot;

    // Independent X and Y collision (prevents getting stuck on walls)
    if (!isWall(player.x + moveX, player.y)) player.x += moveX;
    if (!isWall(player.x, player.y + moveY)) player.y += moveY;

    // Animation Timing
    const now = performance.now();
    const currentAnim = ANIMS[weapon.state];
    if (now - weapon.lastFrameUpdate > weapon.animSpeed) {
        weapon.frame++;
        weapon.lastFrameUpdate = now;

        if (weapon.frame >= currentAnim.length) {
            if (weapon.state === "reload") weapon.ammo = weapon.maxAmmo;
            weapon.state = "idle";
            weapon.frame = 0;
        }
    }
}

/* ================= DRAWING ================= */
function drawUI() {
    // Gun Rendering
    if (weaponSheet.complete) {
        const frameIdx = ANIMS[weapon.state][weapon.frame];
        const displayH = canvas.height * 0.9; // Scale gun to 90% screen height
        const displayW = displayH; 

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height);
        ctx.drawImage(
            weaponSheet,
            frameIdx * SPRITE_SIZE, 0, SPRITE_SIZE, SPRITE_SIZE, // Source
            -displayW / 2, -displayH, displayW, displayH         // Destination
        );
        ctx.restore();
    }

    // HUD
    ctx.fillStyle = "black";
    ctx.fillRect(0, canvas.height - 60, 220, 60);
    ctx.fillStyle = "yellow";
    ctx.font = "bold 30px Courier New";
    ctx.fillText("AMMO: " + weapon.ammo, 20, canvas.height - 20);
    
    // Crosshair
    ctx.strokeStyle = "lime";
    ctx.lineWidth = 2;
    ctx.strokeRect(canvas.width/2 - 4, canvas.height/2 - 4, 8, 8);
}

function drawWalls() {
    const fov = Math.PI / 3;
    for (let x = 0; x < canvas.width; x++) {
        const rayAngle = player.angle - fov/2 + (x/canvas.width)*fov;
        const rayCos = Math.cos(rayAngle);
        const raySin = Math.sin(rayAngle);

        let rx = player.x, ry = player.y;
        let dist = 0, wallId = 0, hitV = false;

        while (dist < 800) {
            let px = rx;
            rx += rayCos * 2; ry += raySin * 2; dist += 2;
            const mx = Math.floor(rx / TILE);
            const my = Math.floor(ry / TILE);
            if (map[my] && map[my][mx] > 0) {
                wallId = map[my][mx];
                hitV = Math.floor(px / TILE) !== mx;
                break;
            }
        }
        if (!wallId) continue;

        const correctedDist = dist * Math.cos(rayAngle - player.angle);
        const wallHeight = (TILE * canvas.height) / correctedDist;
        const yPos = (canvas.height - wallHeight) / 2;

        let hitX = hitV ? ry % TILE : rx % TILE;
        let texX = Math.floor((hitX / TILE) * TEXTURE_SIZE);
        const texture = wallTextures[wallId];
        
        if (texture && texture.complete) {
            ctx.drawImage(texture, texX, 0, 1, TEXTURE_SIZE, x, yPos, 1, wallHeight);
        }
        
        // Depth shading
        ctx.fillStyle = `rgba(0,0,0,${Math.min(0.8, correctedDist/600)})`;
        ctx.fillRect(x, yPos, 1, wallHeight);
    }
}

function loop() {
    update();
    
    // Clear Screen
    ctx.fillStyle = "#111"; // Ceiling
    ctx.fillRect(0, 0, canvas.width, canvas.height/2);
    ctx.fillStyle = "#333"; // Floor
    ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);

    drawWalls();
    drawUI();

    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
