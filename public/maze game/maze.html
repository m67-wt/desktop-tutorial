<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c")
const ctx = canvas.getContext("2d")

// Depth buffer to handle sprite clipping
let zBuffer = [];

function resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    ctx.imageSmoothingEnabled = false
}
window.addEventListener("resize", resize)
resize()

const TILE = 64
// 5 is the Closed Door. In this map, I've placed one at row 1, col 4.
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,5,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,1],
    [1,0,1,0,0,0,1,1,1,1,1,1,1,1],
    [1,0,1,1,1,1,1,0,0,0,0,0,0,1],
    [1,0,5,0,0,0,0,0,3,0,3,0,3,3],
    [1,0,1,1,1,1,1,0,3,0,3,0,3,3],
    [1,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,0,0,1,1,1,1,1,1,1,1],
    [1,5,1,1,1,1,1],
    [1,0,0,3,0,0,1],
    [1,0,0,3,0,0,1],
    [1,0,0,0,0,0,1],
    [1,1,1,1,1,1,1],
]

function loadImg(src) {
    const img = new Image()
    img.src = src
    return img
}

const TEXTURE_SIZE = 500
const wallTextures = [
    null,
    loadImg("assets/wall textures-1.png"),
    loadImg("assets/wall textures-2.png"),
    loadImg("assets/wall textures-3.png"),
    loadImg("assets/wall textures-4.png"),
    loadImg("assets/wall_texture_door-1.png"),      // Index 5: Door Closed
    loadImg("assets/wall_texture_door_open-2.png")  // Index 6: Door Open
]

const keyTexture = loadImg("assets/wall textures-5.png");

const sprites = [
    { x: TILE * 4.5, y: TILE * 1.5, texture: keyTexture, collected: false }
];

const openDoors = {}; // Tracks "row,col" of open doors

const reloadSheet = loadImg("assets/gun_reloading.png")
const fireSheet = loadImg("assets/gun_fire.png")
const faceSheet = loadImg("assets/charater_hurt_models.png")

const ANIMS = {
    idle:   { frames: [0], sheet: reloadSheet, count: 21, speed: 125 },
    fire:   { frames: [0, 1, 2, 3, 4], sheet: fireSheet, count: 5, speed: 166 }, 
    reload: { frames: Array.from({length: 21}, (_, i) => i), sheet: reloadSheet, count: 21, speed: 125 }
}

const weapon = { ammo: 1, state: "idle", frame: 0, lastFrameUpdate: 0, animSpeed: 125 }
const player = { x: TILE * 1.5, y: TILE * 1.5, angle: 0, move: 2.5, rot: 0.05, hp: 100, hasKey: false }
const keys = {}

window.addEventListener("keydown", e => {
    const key = e.key.toLowerCase();
    keys[key] = true;
    if (key === " ") handleAction();
    if (key === "r") reload();
    if (key === "e") tryOpenDoor();
})
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false)
window.addEventListener("mousedown", () => handleAction())

function isWall(x, y) {
    const mx = Math.floor(x / TILE)
    const my = Math.floor(y / TILE)
    const tile = map[my] ? map[my][mx] : 0;
    if (tile === 0) return false;
    if (tile === 5) return !openDoors[`${my},${mx}`]; // Collidable only if not open
    return tile > 0;
}

function tryOpenDoor() {
    const checkDist = 50;
    const dx = player.x + Math.cos(player.angle) * checkDist;
    const dy = player.y + Math.sin(player.angle) * checkDist;
    const mx = Math.floor(dx / TILE);
    const my = Math.floor(dy / TILE);

    if (map[my] && map[my][mx] === 5) {
        const doorKey = `${my},${mx}`;
        openDoors[doorKey] = true;
        setTimeout(() => { delete openDoors[doorKey]; }, 5000);
    }
}

function handleAction() {
    if (weapon.state !== "idle") return
    if (weapon.ammo > 0) shoot()
    else reload()
}

function shoot() {
    weapon.ammo = 0
    weapon.state = "fire"
    weapon.frame = 0
    weapon.animSpeed = ANIMS.fire.speed
    weapon.lastFrameUpdate = performance.now()
}

function reload() {
    if (weapon.state === "idle" && weapon.ammo === 0) {
        weapon.state = "reload"
        weapon.frame = 0
        weapon.animSpeed = ANIMS.reload.speed
        weapon.lastFrameUpdate = performance.now()
    }
}

function update() {
    let moveStep = 0
    if (keys["w"]) moveStep = player.move
    if (keys["s"]) moveStep = -player.move
    if (keys["a"]) player.angle -= player.rot
    if (keys["d"]) player.angle += player.rot

    let nx = player.x + Math.cos(player.angle) * moveStep
    let ny = player.y + Math.sin(player.angle) * moveStep
    if (!isWall(nx, player.y)) player.x = nx
    if (!isWall(player.x, ny)) player.y = ny

    // Sprite Pickup Logic
    sprites.forEach(s => {
        if (!s.collected) {
            const dist = Math.sqrt((player.x - s.x)**2 + (player.y - s.y)**2);
            if (dist < 30) {
                s.collected = true;
                player.hasKey = true;
            }
        }
    });

    const now = performance.now()
    const currentAnim = ANIMS[weapon.state]
    if (weapon.state !== "idle") {
        if (now - weapon.lastFrameUpdate > weapon.animSpeed) {
            weapon.frame++
            weapon.lastFrameUpdate = now
            if (weapon.frame >= currentAnim.frames.length) {
                if (weapon.state === "fire") {
                    weapon.state = "reload"
                    weapon.frame = 0
                } else {
                    weapon.ammo = 1
                    weapon.state = "idle"
                    weapon.frame = 0
                }
            }
        }
    }
}

function drawWalls() {
    const fov = Math.PI / 3
    const HUD_H = 160 
    const viewHeight = canvas.height - HUD_H
    zBuffer = [];
    
    for (let x = 0; x < canvas.width; x++) {
        const rayAngle = player.angle - fov/2 + (x/canvas.width)*fov
        const rayCos = Math.cos(rayAngle), raySin = Math.sin(rayAngle)
        let rx = player.x, ry = player.y, dist = 0, hitV = false

        while (dist < 800) {
            let px = rx
            rx += rayCos * 2; ry += raySin * 2; dist += 2
            let mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE)
            if (map[my] && map[my][mx] > 0) {
                let wallId = map[my][mx];
                
                // Door Visual Swap
                if (wallId === 5 && openDoors[`${my},${mx}`]) wallId = 6;

                hitV = Math.floor(px / TILE) !== mx
                const corrected = dist * Math.cos(rayAngle - player.angle)
                zBuffer[x] = corrected;

                const h = (TILE * viewHeight) / corrected
                const yPos = (viewHeight - h) / 2
                const texture = wallTextures[wallId]
                if (texture && texture.complete) {
                    let hitX = hitV ? ry % TILE : rx % TILE
                    let texX = Math.floor((hitX / TILE) * TEXTURE_SIZE)
                    ctx.drawImage(texture, texX, 0, 1, TEXTURE_SIZE, x, yPos, 1, h)
                }
                ctx.fillStyle = `rgba(0,0,0,${Math.min(0.8, corrected/600)})`
                ctx.fillRect(x, yPos, 1, h)
                break
            }
        }
    }
}

function drawSprites() {
    const viewHeight = canvas.height - 160;
    const fov = Math.PI / 3;

    sprites.forEach(sprite => {
        if (sprite.collected || !sprite.texture.complete) return;

        const dx = sprite.x - player.x;
        const dy = sprite.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        let spriteAngle = Math.atan2(dy, dx) - player.angle;
        while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
        while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

        const correctedDist = dist * Math.cos(spriteAngle);
        
        if (Math.abs(spriteAngle) < fov && correctedDist > 10) {
            const sHeight = (TILE * viewHeight) / correctedDist;
            const sWidth = sHeight; 
            const screenX = (0.5 * (spriteAngle / (fov / 2)) + 0.5) * canvas.width;
            const screenY = (viewHeight - sHeight) / 2;

            for (let i = 0; i < sWidth; i++) {
                const colX = Math.floor(screenX - sWidth/2 + i);
                if (colX >= 0 && colX < canvas.width && zBuffer[colX] > correctedDist) {
                    const texX = Math.floor((i / sWidth) * sprite.texture.width);
                    ctx.drawImage(sprite.texture, texX, 0, 1, sprite.texture.height, colX, screenY, 1, sHeight);
                }
            }
        }
    });
}

function getFaceIndex() {
    if (player.hp >= 100) return 0
    if (player.hp >= 80) return 1
    if (player.hp >= 60) return 2
    if (player.hp >= 40) return 3
    return 4 
}

function drawWeapon() {
    const currentAnim = ANIMS[weapon.state]
    const sheet = currentAnim.sheet
    const hudTop = canvas.height - 160

    if (sheet.complete && sheet.width > 0) {
        const frameW = sheet.width / currentAnim.count
        const frameH = sheet.height
        const frameIdx = currentAnim.frames[weapon.frame]
        const displayH = canvas.height * 0.70
        const displayW = displayH * (frameW / frameH)
        
        ctx.save()
        ctx.translate(canvas.width * 0.25, hudTop)
        ctx.rotate(15 * Math.PI / 180)
        ctx.drawImage(sheet, frameIdx * frameW, 0, frameW, frameH, -displayW * 0.1, -displayH * 0.95, displayW, displayH)
        ctx.restore()
    }
}

function drawHUD() {
    const HUD_H = 160
    const hudTop = canvas.height - HUD_H
    ctx.fillStyle = "#222"; ctx.fillRect(0, hudTop, canvas.width, HUD_H)
    
    const portraitX = 40; const portraitY = hudTop + 10; const portraitSize = 85
    ctx.fillStyle = "#000"; ctx.fillRect(portraitX, portraitY, portraitSize, portraitSize)

    if (faceSheet.complete) {
        const faceW = 64; const faceIdx = getFaceIndex()
        ctx.drawImage(faceSheet, faceIdx * faceW, 0, 64, 64, portraitX+5, portraitY+5, portraitSize-10, portraitSize-10)
    }

    ctx.fillStyle = "red"; ctx.font = "bold 16px monospace"; ctx.fillText("HEALTH", portraitX, hudTop + 115) 
    ctx.fillStyle = "white"; ctx.font = "bold 40px monospace"; ctx.fillText(`${player.hp}%`, portraitX, hudTop + 150)

    ctx.fillStyle = "yellow"; ctx.font = "bold 16px monospace"; ctx.fillText("AMMO", canvas.width - 120, hudTop + 40)
    ctx.fillStyle = "white"; ctx.font = "bold 30px monospace"; ctx.fillText(weapon.ammo > 0 ? "1 / 1" : "0 / 1", canvas.width - 120, hudTop + 80)

    if (player.hasKey) {
        ctx.fillStyle = "gold"; ctx.font = "bold 18px monospace"; ctx.fillText("KEY OBTAINED", canvas.width/2 - 60, hudTop + 80);
    }
}

function loop() {
    update()
    const viewH = canvas.height - 160
    ctx.fillStyle = "#1a1a1a"; ctx.fillRect(0, 0, canvas.width, viewH/2)
    ctx.fillStyle = "#222"; ctx.fillRect(0, viewH/2, canvas.width, viewH/2)
    
    drawWalls()
    drawSprites()
    drawWeapon()
    drawHUD()
    
    requestAnimationFrame(loop)
}
loop()
</script>
</body>
</html>

