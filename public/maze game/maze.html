<head>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c")
const ctx = canvas.getContext("2d")

function resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    ctx.imageSmoothingEnabled = false
}
window.addEventListener("resize", resize)
resize()

const TILE = 64
const map = [
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4],
    [4,0,1,1,1,0,2,2,0,0,0,0,0,0,0,0,0,0,0,4],
    [4,0,0,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,4],
    [4,0,3,0,1,0,4,0,0,3,0,0,0,0,0,0,0,0,0,4],
    [4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]
]

function loadImg(src) {
    const img = new Image()
    img.src = src
    return img
}

const TEXTURE_SIZE = 500
const wallTextures = [
    null,
    loadImg("assets/wall textures-1.png"),
    loadImg("assets/wall textures-2.png"),
    loadImg("assets/wall textures-3.png"),
    loadImg("assets/wall textures-4.png")
]

const reloadSheet = loadImg("assets/gun_reloading.png")
const fireSheet = loadImg("assets/gun_fire.png")
const faceSheet = loadImg("assets/charater_hurt_models.png")
const zombieSheet = loadImg("assets/zombie_animation.png")

const ANIMS = {
    idle:   { frames: [0], sheet: reloadSheet, count: 21, speed: 125 },
    fire:   { frames: [0, 1, 2, 3, 4], sheet: fireSheet, count: 5, speed: 166 }, 
    reload: { frames: Array.from({length: 21}, (_, i) => i), sheet: reloadSheet, count: 21, speed: 125 }
}

const weapon = { ammo: 1, state: "idle", frame: 0, lastFrameUpdate: 0, animSpeed: 125 }
const player = { x: TILE * 1.5, y: TILE * 1.5, angle: 0, move: 3.5, rot: 0.05, hp: 100 }
const keys = {}

const fred = {
    x: TILE * 8,
    y: TILE * 4,
    hp: 2,
    alive: true,
    speed: 1.2,
    frame: 0,
    lastFrameUpdate: 0,
    lastAttack: 0
}

window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true
    if (e.key === " ") handleAction()
    if (e.key.toLowerCase() === "r") reload()
})
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false)
window.addEventListener("mousedown", () => handleAction())

function isWall(x, y) {
    const mx = Math.floor(x / TILE)
    const my = Math.floor(y / TILE)
    if (my < 0 || my >= map.length || mx < 0 || mx >= map[0].length) return true
    return map[my][mx] > 0
}

function handleAction() {
    if (weapon.state !== "idle") return
    if (weapon.ammo > 0) shoot()
    else reload()
}

function shoot() {
    weapon.ammo = 0
    weapon.state = "fire"
    weapon.frame = 0
    weapon.lastFrameUpdate = performance.now()

    if (fred.alive) {
        const dx = fred.x - player.x
        const dy = fred.y - player.y
        const angleToFred = Math.atan2(dy, dx)
        let angleDiff = player.angle - angleToFred
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2
        const dist = Math.sqrt(dx*dx + dy*dy)
        if (Math.abs(angleDiff) < 0.2 && dist < 500) {
            fred.hp--
            if (fred.hp <= 0) fred.alive = false
        }
    }
}

function reload() {
    if (weapon.state === "idle" && weapon.ammo === 0) {
        weapon.state = "reload"
        weapon.frame = 0
        weapon.lastFrameUpdate = performance.now()
    }
}

function update() {
    let moveStep = 0
    if (keys["w"]) moveStep = player.move
    if (keys["s"]) moveStep = -player.move
    if (keys["a"]) player.angle -= player.rot
    if (keys["d"]) player.angle += player.rot

    let nx = player.x + Math.cos(player.angle) * moveStep
    let ny = player.y + Math.sin(player.angle) * moveStep
    if (!isWall(nx, player.y)) player.x = nx
    if (!isWall(player.x, ny)) player.y = ny

    if (fred.alive) {
        const dx = player.x - fred.x
        const dy = player.y - fred.y
        const dist = Math.sqrt(dx*dx + dy*dy)
        if (dist > 40) {
            const angle = Math.atan2(dy, dx)
            const mx = fred.x + Math.cos(angle) * fred.speed
            const my = fred.y + Math.sin(angle) * fred.speed
            if (!isWall(mx, fred.y)) fred.x = mx
            if (!isWall(fred.x, my)) fred.y = my
        } else {
            const now = performance.now()
            if (now - fred.lastAttack > 2000) {
                player.hp = Math.max(0, player.hp - 15)
                fred.lastAttack = now
            }
        }
        if (performance.now() - fred.lastFrameUpdate > 200) {
            fred.frame = (fred.frame + 1) % 4
            fred.lastFrameUpdate = performance.now()
        }
    }

    const now = performance.now()
    const anim = ANIMS[weapon.state]
    if (weapon.state !== "idle" && now - weapon.lastFrameUpdate > anim.speed) {
        weapon.frame++
        weapon.lastFrameUpdate = now
        if (weapon.frame >= anim.frames.length) {
            if (weapon.state === "fire") {
                weapon.state = "reload"
                weapon.frame = 0
            } else {
                weapon.ammo = 1
                weapon.state = "idle"
                weapon.frame = 0
            }
        }
    }
}

let zBuffer = new Array(2000).fill(0)

function drawWalls() {
    const fov = Math.PI / 3
    const viewH = canvas.height - 160
    for (let x = 0; x < canvas.width; x++) {
        const rayAngle = player.angle - fov/2 + (x/canvas.width)*fov
        const rayCos = Math.cos(rayAngle), raySin = Math.sin(rayAngle)
        let rx = player.x, ry = player.y, dist = 0
        while (dist < 800) {
            rx += rayCos * 2; ry += raySin * 2; dist += 2
            let mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE)
            if (map[my] && map[my][mx] > 0) {
                const corrected = dist * Math.cos(rayAngle - player.angle)
                zBuffer[x] = corrected
                const h = (TILE * viewH) / corrected
                const yPos = (viewH - h) / 2
                const tex = wallTextures[map[my][mx]]
                if (tex && tex.complete) {
                    let hitX = (Math.floor(rx) % TILE === 0 || Math.floor(rx) % TILE === TILE - 1) ? ry % TILE : rx % TILE
                    ctx.drawImage(tex, Math.floor((hitX / TILE) * TEXTURE_SIZE), 0, 1, TEXTURE_SIZE, x, yPos, 1, h)
                }
                ctx.fillStyle = `rgba(0,0,0,${Math.min(0.8, corrected/600)})`
                ctx.fillRect(x, yPos, 1, h)
                break
            }
        }
    }
}

function drawSprites() {
    if (!fred.alive || !zombieSheet.complete) return
    const viewH = canvas.height - 160
    const fov = Math.PI / 3
    const dx = fred.x - player.x
    const dy = fred.y - player.y
    const dist = Math.sqrt(dx*dx + dy*dy)
    let spriteAngle = Math.atan2(dy, dx) - player.angle
    while (spriteAngle < -Math.PI) spriteAngle += Math.PI * 2
    while (spriteAngle > Math.PI) spriteAngle -= Math.PI * 2
    if (Math.abs(spriteAngle) > fov) return
    const cosAngle = Math.cos(spriteAngle)
    if (cosAngle <= 0) return
    const size = (TILE * viewH) / (dist * cosAngle)
    const xPos = (0.5 * (spriteAngle / (fov / 2)) + 0.5) * canvas.width - size / 2
    const yPos = (viewH - size) / 2
    for (let col = 0; col < size; col++) {
        const sx = Math.floor(xPos + col)
        if (sx >= 0 && sx < canvas.width && zBuffer[sx] > dist) {
            ctx.drawImage(zombieSheet, fred.frame * 64 + Math.floor((col / size) * 64), 0, 1, 64, sx, yPos, 1, size)
        }
    }
}

function drawWeapon() {
    const anim = ANIMS[weapon.state]
    const sheet = anim.sheet
    if (!sheet.complete) return
    const fw = sheet.width / anim.count
    const dh = canvas.height * 0.7
    const dw = dh * (fw / sheet.height)
    ctx.save()
    ctx.translate(canvas.width * 0.25, canvas.height - 160)
    ctx.rotate(15 * Math.PI / 180)
    ctx.drawImage(sheet, anim.frames[weapon.frame] * fw, 0, fw, sheet.height, -dw * 0.1, -dh * 0.95, dw, dh)
    ctx.restore()
}

function drawHUD() {
    const hTop = canvas.height - 160
    ctx.fillStyle = "#222"
    ctx.fillRect(0, hTop, canvas.width, 160)
    if (faceSheet.complete) {
        const idx = player.hp >= 100 ? 0 : player.hp >= 80 ? 1 : player.hp >= 60 ? 2 : player.hp >= 40 ? 3 : 4
        ctx.drawImage(faceSheet, idx * 64, 0, 64, 64, 45, hTop + 15, 75, 75)
    }
    ctx.fillStyle = "white"
    ctx.font = "bold 40px monospace"
    ctx.fillText(`${player.hp}%`, 40, hTop + 150)
    ctx.fillText(weapon.ammo > 0 ? "1/1" : "0/1", canvas.width - 120, hTop + 80)
}

function loop() {
    update()
    const viewH = canvas.height - 160
    ctx.fillStyle = "#1a1a1a"; ctx.fillRect(0, 0, canvas.width, viewH/2)
    ctx.fillStyle = "#222"; ctx.fillRect(0, viewH/2, canvas.width, viewH/2)
    drawWalls()
    drawSprites()
    drawWeapon()
    drawHUD()
    requestAnimationFrame(loop)
}
loop()
</script>
</body>
