<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let zBuffer = [];

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageSmoothingEnabled = false;
}
window.addEventListener("resize", resize);
resize();

const TILE = 64;
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,5,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,1,0,0,0,1,1,1,1,1,1,1,1],
    [1,0,1,1,1,1,1,0,0,0,0,0,0,1],
    [1,0,5,0,0,0,0,0,3,0,3,0,3,3],
    [1,0,1,1,1,1,1,0,3,0,3,0,3,3],
    [1,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,0,0,1,1,1,1,1,1,1,1],
    [1,5,1,1,1,1,1],
    [1,0,0,3,0,0,1],
    [1,0,0,3,0,0,1],
    [1,0,0,0,0,0,1],
    [1,1,1,1,1,1,1],
];

function loadImg(src) {
    const img = new Image();
    img.src = src;
    return img;
}

const wallTextures = [
    null,
    loadImg("assets/wall textures-1.png"),
    loadImg("assets/wall textures-2.png"),
    loadImg("assets/wall textures-3.png"),
    loadImg("assets/wall textures-4.png"),
    loadImg("assets/wall_texture_door-1.png"),
    loadImg("assets/wall_texture_door_open-2.png")
];

const keyTexture = loadImg("assets/wall textures-5.png");
const sprites = [{ x: TILE * 4.5, y: TILE * 1.5, texture: keyTexture, collected: false }];
const openDoors = {};

const reloadSheet = loadImg("assets/gun_reloading.png");
const fireSheet = loadImg("assets/gun_fire.png");
const faceSheet = loadImg("assets/charater_hurt_models.png");

const weapon = { ammo: 1, state: "idle", frame: 0, lastUpdate: 0 };
const player = { x: TILE * 1.5, y: TILE * 1.5, angle: 0, hp: 100, hasKey: false };
const keys = {};

window.onkeydown = e => { keys[e.key.toLowerCase()] = true; if(e.key === "e") tryOpenDoor(); if(e.key === " ") shoot(); };
window.onkeyup = e => keys[e.key.toLowerCase()] = false;

function tryOpenDoor() {
    const mx = Math.floor((player.x + Math.cos(player.angle) * 50) / TILE);
    const my = Math.floor((player.y + Math.sin(player.angle) * 50) / TILE);
    if (map[my] && map[my][mx] === 5) {
        const id = `${my},${mx}`;
        openDoors[id] = true;
        setTimeout(() => delete openDoors[id], 5000);
    }
}

function shoot() {
    if (weapon.state === "idle" && weapon.ammo > 0) {
        weapon.ammo = 0; weapon.state = "fire"; weapon.frame = 0; weapon.lastUpdate = performance.now();
    }
}

function update() {
    const rotSpeed = 0.04, moveSpeed = 2.5;
    if (keys["a"]) player.angle -= rotSpeed;
    if (keys["d"]) player.angle += rotSpeed;
    const moveX = Math.cos(player.angle) * moveSpeed;
    const moveY = Math.sin(player.angle) * moveSpeed;
    if (keys["w"]) {
        if (!isWall(player.x + moveX, player.y)) player.x += moveX;
        if (!isWall(player.x, player.y + moveY)) player.y += moveY;
    }
    if (keys["s"]) {
        if (!isWall(player.x - moveX, player.y)) player.x -= moveX;
        if (!isWall(player.x, player.y - moveY)) player.y -= moveY;
    }

    // Key collection
    sprites.forEach(s => {
        if (!s.collected && Math.hypot(player.x - s.x, player.y - s.y) < 30) {
            s.collected = true; player.hasKey = true;
        }
    });

    // Weapon Animation
    const now = performance.now();
    if (weapon.state !== "idle" && now - weapon.lastUpdate > 120) {
        weapon.frame++; weapon.lastUpdate = now;
        if (weapon.state === "fire" && weapon.frame > 4) { weapon.state = "reload"; weapon.frame = 0; }
        if (weapon.state === "reload" && weapon.frame > 20) { weapon.state = "idle"; weapon.frame = 0; weapon.ammo = 1; }
    }
}

function isWall(x, y) {
    const mx = Math.floor(x / TILE), my = Math.floor(y / TILE);
    if (!map[my] || !map[my][mx]) return false;
    if (map[my][mx] === 5) return !openDoors[`${my},${mx}`];
    return map[my][mx] > 0;
}

function draw() {
    update();
    const vH = canvas.height - 160;
    ctx.fillStyle = "#111"; ctx.fillRect(0, 0, canvas.width, vH / 2);
    ctx.fillStyle = "#222"; ctx.fillRect(0, vH / 2, canvas.width, vH / 2);

    const fov = Math.PI / 3;
    zBuffer = [];

    for (let x = 0; x < canvas.width; x++) {
        let rayAngle = player.angle - fov / 2 + (x / canvas.width) * fov;
        let rayDirX = Math.cos(rayAngle), rayDirY = Math.sin(rayAngle);
        
        let mapX = Math.floor(player.x / TILE), mapY = Math.floor(player.y / TILE);
        let deltaDistX = Math.abs(1 / rayDirX), deltaDistY = Math.abs(1 / rayDirY);
        let stepX, stepY, sideDistX, sideDistY;

        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x / TILE - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x / TILE) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (player.y / TILE - mapY) * deltaDistY; }
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y / TILE) * deltaDistY; }

        let hit = 0, side, dist;
        while (hit === 0) {
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            
            let tile = map[mapY] ? map[mapY][mapX] : 0;
            if (tile > 0) {
                let isDoorOpen = (tile === 5 && openDoors[`${mapY},${mapX}`]);
                dist = side === 0 ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
                let corrDist = dist * Math.cos(rayAngle - player.angle);
                
                // Draw the slice
                let h = (TILE * vH) / corrDist;
                let tex = wallTextures[isDoorOpen ? 6 : tile];
                if (tex && tex.complete) {
                    let wallX = side === 0 ? (player.y / TILE + dist * rayDirY) : (player.x / TILE + dist * rayDirX);
                    wallX -= Math.floor(wallX);
                    ctx.drawImage(tex, wallX * 500, 0, 1, 500, x, (vH - h) / 2, 1, h);
                }
                
                if (!isDoorOpen) { hit = 1; zBuffer[x] = corrDist; }
            }
            if (dist > 20) break; // Safety
        }
    }

    // Sprites
    sprites.forEach(s => {
        if (s.collected) return;
        let dx = s.x - player.x, dy = s.y - player.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        let angle = Math.atan2(dy, dx) - player.angle;
        if (angle < -Math.PI) angle += 2*Math.PI; if (angle > Math.PI) angle -= 2*Math.PI;
        if (Math.abs(angle) < fov) {
            let h = (TILE * vH) / (dist * Math.cos(angle));
            let sx = (0.5 * (angle / (fov / 2)) + 0.5) * canvas.width;
            for (let i = 0; i < h; i++) {
                let cx = Math.floor(sx - h/2 + i);
                if (cx > 0 && cx < canvas.width && zBuffer[cx] > dist) {
                    ctx.drawImage(s.texture, (i/h)*500, 0, 1, 500, cx, (vH-h)/2, 1, h);
                }
            }
        }
    });

    drawWeapon(); drawHUD();
    requestAnimationFrame(draw);
}

function drawWeapon() {
    let sheet = weapon.state === "fire" ? fireSheet : reloadSheet;
    if (sheet.complete) {
        let fw = sheet.width / (weapon.state === "fire" ? 5 : 21);
        let h = canvas.height * 0.7; let w = h * (fw / sheet.height);
        ctx.drawImage(sheet, weapon.frame * fw, 0, fw, sheet.height, canvas.width/2 - w/2, canvas.height - 160 - h, w, h);
    }
}

function drawHUD() {
    const top = canvas.height - 160;
    ctx.fillStyle = "#222"; ctx.fillRect(0, top, canvas.width, 160);
    ctx.fillStyle = "white"; ctx.font = "20px Arial";
    ctx.fillText(`HP: ${player.hp}%`, 50, top + 50);
    ctx.fillText(`AMMO: ${weapon.ammo}/1`, 50, top + 90);
    if (player.hasKey) ctx.fillText("KEY FOUND", canvas.width - 150, top + 50);
}

draw();
</script>
</body>
</html>
