<!DOCTYPE html>
<html>
<head>
    <title>Wolfenstein Raycaster - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: monospace; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c")
const ctx = canvas.getContext("2d")

let zBuffer = [];

function resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    ctx.imageSmoothingEnabled = false
}
window.addEventListener("resize", resize)
resize()

const TILE = 64
const TEXTURE_SIZE = 500

// Map: 5=Normal, 6=Silver, 7=Gold, 8=Ruby
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,5,0,6,0,7,0,8,0,0,0,0,0,1], 
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

function loadImg(src) {
    const img = new Image();
    img.src = src;
    return img;
}

// Fixed Texture Array
const wallTextures = [
    null,                                           // 0
    loadImg("assets/wall textures-1.png"),          // 1
    loadImg("assets/wall textures-2.png"),          // 2
    loadImg("assets/wall textures-3.png"),          // 3
    loadImg("assets/wall textures-4.png"),          // 4
    loadImg("assets/wall_texture_door-1.png"),      // 5: Normal Door Closed
    loadImg("assets/wall_texture_door_open-2.png"), // 6: Normal Door Open (used internally)
    loadImg("assets/wall_texture_silver_door-1.png"),// 7: Silver Door Closed
    loadImg("assets/wall_texture_silver_door_open-2.png"), // 8: Silver Door Open
    loadImg("assets/wall_texture_gold_door-3.png"),  // 9: Gold Door Closed
    loadImg("assets/wall_texture_gold_door_open-4.png"),   // 10: Gold Door Open
    loadImg("assets/wall_texture_ruby_door-5.png"),  // 11: Ruby Door Closed
    loadImg("assets/wall_texture_ruby_door_open-6.png")    // 12: Ruby Door Open
];

const sprites = [
    { x: TILE * 4.5, y: TILE * 3.5, texture: loadImg("assets/wall_texture_silver_door-1.png"), type: 'silver', collected: false },
    { x: TILE * 6.5, y: TILE * 3.5, texture: loadImg("assets/wall textures-5.png"), type: 'gold', collected: false },
    { x: TILE * 8.5, y: TILE * 3.5, texture: loadImg("assets/wall_texture_ruby_door-5.png"), type: 'ruby', collected: false }
];

const openDoors = {}; 
const faceSheet = loadImg("assets/charater_hurt_models.png");
const keys = {};

const player = { 
    x: TILE * 1.5, y: TILE * 1.5, angle: 0, move: 2.5, rot: 0.05, hp: 100,
    inventory: { gold: false, silver: false, ruby: false }
};

window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === "e") tryOpenDoor();
});
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

function isWall(x, y) {
    const mx = Math.floor(x / TILE), my = Math.floor(y / TILE);
    if (!map[my] || map[my][mx] === undefined) return true;
    const tile = map[my][mx];
    if ([5, 6, 7, 8].includes(tile) && openDoors[`${my},${mx}`]) return false;
    return tile > 0;
}

function tryOpenDoor() {
    const dx = player.x + Math.cos(player.angle) * 64;
    const dy = player.y + Math.sin(player.angle) * 64;
    const mx = Math.floor(dx / TILE), my = Math.floor(dy / TILE);
    
    if (map[my]) {
        const tile = map[my][mx];
        const doorPos = `${my},${mx}`;
        let canOpen = false;

        if (tile === 5) canOpen = true;
        if (tile === 6 && player.inventory.silver) canOpen = true;
        if (tile === 7 && player.inventory.gold) canOpen = true;
        if (tile === 8 && player.inventory.ruby) canOpen = true;

        if (canOpen && !openDoors[doorPos]) {
            openDoors[doorPos] = true;
            setTimeout(() => { delete openDoors[doorPos]; }, 5000);
        }
    }
}

function update() {
    let moveStep = 0;
    if (keys["w"]) moveStep = player.move;
    if (keys["s"]) moveStep = -player.move;
    if (keys["a"]) player.angle -= player.rot;
    if (keys["d"]) player.angle += player.rot;

    let nx = player.x + Math.cos(player.angle) * moveStep;
    let ny = player.y + Math.sin(player.angle) * moveStep;
    if (!isWall(nx, player.y)) player.x = nx;
    if (!isWall(player.x, ny)) player.y = ny;

    sprites.forEach(s => {
        if (!s.collected) {
            const d = Math.sqrt((player.x - s.x)**2 + (player.y - s.y)**2);
            if (d < 30) { s.collected = true; player.inventory[s.type] = true; }
        }
    });
}

function draw() {
    const viewH = canvas.height - 160;
    const fov = Math.PI / 3;
    
    // Background
    ctx.fillStyle = "#1a1a1a"; ctx.fillRect(0, 0, canvas.width, viewH/2);
    ctx.fillStyle = "#222"; ctx.fillRect(0, viewH/2, canvas.width, viewH/2);

    zBuffer = [];
    for (let x = 0; x < canvas.width; x++) {
        const rayAngle = player.angle - fov/2 + (x/canvas.width)*fov;
        const rayCos = Math.cos(rayAngle), raySin = Math.sin(rayAngle);
        let rx = player.x, ry = player.y, dist = 0;

        while (dist < 1000) {
            rx += rayCos * 2; ry += raySin * 2; dist += 2;
            let mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE);
            
            if (map[my] && map[my][mx] > 0) {
                let tid = map[my][mx];
                let texIdx = tid;

                // Door Rendering logic
                if (tid === 5) texIdx = openDoors[`${my},${mx}`] ? 6 : 5;
                if (tid === 6) texIdx = openDoors[`${my},${mx}`] ? 8 : 7;
                if (tid === 7) texIdx = openDoors[`${my},${mx}`] ? 10 : 9;
                if (tid === 8) texIdx = openDoors[`${my},${mx}`] ? 12 : 11;

                const corr = dist * Math.cos(rayAngle - player.angle);
                zBuffer[x] = corr;
                const h = (TILE * viewH) / corr;
                const tex = wallTextures[texIdx];
                
                if (tex && tex.complete) {
                    let hitV = Math.floor((rx - rayCos * 2) / TILE) !== mx;
                    let texX = Math.floor(((hitV ? ry % TILE : rx % TILE) / TILE) * TEXTURE_SIZE);
                    ctx.drawImage(tex, texX, 0, 1, TEXTURE_SIZE, x, (viewH-h)/2, 1, h);
                }
                break;
            }
        }
    }

    // Sprites
    sprites.forEach(s => {
        if (s.collected || !s.texture.complete) return;
        const dx = s.x - player.x, dy = s.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let ang = Math.atan2(dy, dx) - player.angle;
        while (ang < -Math.PI) ang += 2 * Math.PI;
        while (ang > Math.PI) ang -= 2 * Math.PI;
        const corr = dist * Math.cos(ang);
        if (Math.abs(ang) < fov && corr > 10) {
            const h = (TILE * viewH) / corr;
            const sx = (0.5 * (ang / (fov / 2)) + 0.5) * canvas.width;
            for (let i = 0; i < h; i++) {
                const cx = Math.floor(sx - h/2 + i);
                if (cx >= 0 && cx < canvas.width && zBuffer[cx] > corr) {
                    const texX = Math.floor((i/h) * s.texture.width);
                    ctx.drawImage(s.texture, texX, 0, 1, s.texture.height, cx, (viewH-h)/2, 1, h);
                }
            }
        }
    });

    // HUD
    const top = canvas.height - 160;
    ctx.fillStyle = "#333"; ctx.fillRect(0, top, canvas.width, 160);
    if (faceSheet.complete) ctx.drawImage(faceSheet, 0, 0, 64, 64, 40, top+20, 80, 80);
    
    ctx.fillStyle = "white"; ctx.font = "14px monospace";
    ctx.fillText("INVENTORY:", 150, top + 40);
    if (player.inventory.silver) { ctx.fillStyle = "silver"; ctx.fillText("[SILVER KEY]", 150, top + 65); }
    if (player.inventory.gold) { ctx.fillStyle = "gold"; ctx.fillText("[GOLD KEY]", 150, top + 90); }
    if (player.inventory.ruby) { ctx.fillStyle = "#ff4444"; ctx.fillText("[RUBY KEY]", 150, top + 115); }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
