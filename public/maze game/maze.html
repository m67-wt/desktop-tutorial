<!DOCTYPE html>
<html>
<head>
    <title>Wolfenstein Raycaster</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: monospace; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c")
const ctx = canvas.getContext("2d")

let zBuffer = [];

function resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    ctx.imageSmoothingEnabled = false
}
window.addEventListener("resize", resize)
resize()

const TILE = 64

const map = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,4,3],
    [2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,3],
    [2,0,0,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,4],
    [2,0,0,5,0,0,0,0,0,0,5,0,0,0,0,0,0,2,0,1,0,1,1,1,5,1,1,1,1,5,1,1,4,0,0,0,3],
    [2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,4],
    [0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,1,0,1,1,0,0,0,0,1,0,0,0,1,3,4,4,3,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,3,3,0,3,3,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,3,0,0,0,0,3,3,3,3,3,3,3,4,0,0,0,0,3,0,0,4],
    [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,5,0,0,0,0,0,5,0,0,0,0,0,0,7,0,3,3,0,3,3,0,4],
    [0,0,0,0,0,2,2,2,2,2,2,0,0,3,0,3,0,2,3,0,0,0,0,3,3,3,0,3,3,3,4,0,0,0,0,0,0,0,4],
    [0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,2,3,3,5,3,3,3,0,3,0,3,0,0,4,0,3,3,0,3,3,0,4],
    [0,0,0,0,0,2,0,2,2,2,2,0,0,3,0,3,0,2,0,4,0,4,0,0,0,3,0,3,0,0,4,0,0,0,0,0,0,0,4],
    [0,0,0,0,0,2,0,2,0,0,2,2,2,2,2,2,2,2,0,4,0,4,0,0,0,2,0,2,0,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,4,0,4,0,0,0,2,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,0,5,0,0,0,0,0,0,0,0,1,0,0,4,0,4,0,0,0,2,0,2,0,2,6,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,4,0,4,0,0,0,2,0,2,2,2,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,3,1,3,0,1,1,1,0,0,0,0,0,0,0,4,4,4,0,4,4,4,4,2,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0],
    [0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,2,2,2,0,0,2,0,0,0,0,0,0,0,0],
    [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,4,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,8,0,0,0,0,0,2,0,0,0,0,0,0,0,0],
    [1,1,5,1,0,0,0,0,0,0,0,0,0,0,0,0,1,3,4,4,4,3,1,4,4,4,4,5,4,4,4,4,0,0,0,0,0,0,5,0,0,0,0,0,2,2,2,2,0,0,2,0,0,0,0,0,0,0,0],
    [1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,3,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,0,0,0],
    [3,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,4,4,0,3,0,3,0,3,0,4,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,3,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,3,4,4,4,3,1,4,0,3,0,3,0,3,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,3,0,3,0,3,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4],
];

function loadImg(src) {
    const img = new Image();
    img.src = src;
    return img;
}

const TEXTURE_SIZE = 500
const wallTextures = [
    null,
    loadImg("assets/wall textures-1.png"),      
    loadImg("assets/wall textures-2.png"),      
    loadImg("assets/wall textures-3.png"),      
    loadImg("assets/wall textures-4.png"),      
    loadImg("assets/wall_texture_door-1.png"),  
    loadImg("assets/wall_texture_door_open-2.png"),
    loadImg("assets/wall textures-5.png"), // Texture for Key 6, 7, 8
    loadImg("assets/wall textures-5.png")
]

const openDoors = {}; 
const reloadSheet = loadImg("assets/gun_reloading.png")
const fireSheet = loadImg("assets/gun_fire.png")
const faceSheet = loadImg("assets/charater_hurt_models.png")

const ANIMS = {
    idle:   { frames: [0], sheet: reloadSheet, count: 21, speed: 125 },
    fire:   { frames: [0, 1, 2, 3, 4], sheet: fireSheet, count: 5, speed: 166 }, 
    reload: { frames: Array.from({length: 21}, (_, i) => i), sheet: reloadSheet, count: 21, speed: 125 }
}

const weapon = { ammo: 1, state: "idle", frame: 0, lastFrameUpdate: 0, animSpeed: 125 }
const player = { x: TILE * 2.5, y: TILE * 2.0, angle: 0, move: 2.5, rot: 0.05, hp: 100, hasKey: false }
const keys = {}

window.addEventListener("keydown", e => {
    const k = e.key.toLowerCase();
    keys[k] = true;
    if (k === " ") handleAction();
    if (k === "r") reload();
    if (k === "e") tryOpenDoor();
})
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false)

function isWall(x, y) {
    const mx = Math.floor(x / TILE), my = Math.floor(y / TILE);
    if (!map[my] || map[my][mx] === undefined) return true;
    const tile = map[my][mx];
    
    // Key Collection Logic (Tiles 6, 7, 8)
    if (tile >= 6 && tile <= 8) {
        map[my][mx] = 0; // Remove key from map
        player.hasKey = true;
        return false;
    }

    const pmx = Math.floor(player.x / TILE);
    const pmy = Math.floor(player.y / TILE);
    
    // Door logic: If open OR player is standing in it, treat as air
    if (tile === 5 && (openDoors[`${my},${mx}`] || (mx === pmx && my === pmy))) return false;
    
    return tile > 0;
}

function tryOpenDoor() {
    const checkDist = 60;
    const dx = player.x + Math.cos(player.angle) * checkDist;
    const dy = player.y + Math.sin(player.angle) * checkDist;
    const mx = Math.floor(dx / TILE), my = Math.floor(dy / TILE);
    
    if (map[my] && map[my][mx] === 5) {
        const doorKey = `${my},${mx}`;
        if (!openDoors[doorKey]) {
            openDoors[doorKey] = true;
            setTimeout(() => { delete openDoors[doorKey]; }, 5000);
        }
    }
}

function handleAction() {
    if (weapon.state !== "idle") return;
    if (weapon.ammo > 0) shoot(); else reload();
}

function shoot() {
    weapon.ammo = 0; weapon.state = "fire"; weapon.frame = 0;
    weapon.animSpeed = ANIMS.fire.speed; weapon.lastFrameUpdate = performance.now();
}

function reload() {
    if (weapon.state === "idle" && weapon.ammo === 0) {
        weapon.state = "reload"; weapon.frame = 0;
        weapon.animSpeed = ANIMS.reload.speed; weapon.lastFrameUpdate = performance.now();
    }
}

function update() {
    let moveStep = 0;
    if (keys["w"]) moveStep = player.move;
    if (keys["s"]) moveStep = -player.move;
    if (keys["a"]) player.angle -= player.rot;
    if (keys["d"]) player.angle += player.rot;

    let nx = player.x + Math.cos(player.angle) * moveStep;
    let ny = player.y + Math.sin(player.angle) * moveStep;
    if (!isWall(nx, player.y)) player.x = nx;
    if (!isWall(player.x, ny)) player.y = ny;

    const now = performance.now();
    const anim = ANIMS[weapon.state];
    if (weapon.state !== "idle" && now - weapon.lastFrameUpdate > weapon.animSpeed) {
        weapon.frame++;
        weapon.lastFrameUpdate = now;
        if (weapon.frame >= anim.frames.length) {
            if (weapon.state === "fire") { weapon.state = "reload"; weapon.frame = 0; }
            else { weapon.ammo = 1; weapon.state = "idle"; weapon.frame = 0; }
        }
    }
}

function drawWalls() {
    const fov = Math.PI / 3;
    const viewH = canvas.height - 160;
    zBuffer = [];
    const pmx = Math.floor(player.x / TILE);
    const pmy = Math.floor(player.y / TILE);

    for (let x = 0; x < canvas.width; x++) {
        const rayAngle = player.angle - fov/2 + (x/canvas.width)*fov;
        const rayCos = Math.cos(rayAngle), raySin = Math.sin(rayAngle);
        let rx = player.x, ry = player.y, dist = 0;

        while (dist < 1200) {
            rx += rayCos * 2; 
            ry += raySin * 2; 
            dist += 2;
            
            let mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE);
            if (map[my] && map[my][mx] > 0) {
                let tid = map[my][mx];
                
                if (tid === 5 && mx === pmx && my === pmy) continue;
                if (tid === 5 && openDoors[`${my},${mx}`]) tid = 6;
                // Map keys 6, 7, 8 to the key texture index
                let drawTid = (tid >= 6 && tid <= 8) ? 7 : tid;

                const corr = dist * Math.cos(rayAngle - player.angle);
                zBuffer[x] = corr; 
                const h = (TILE * viewH) / corr;
                const yPos = (viewH - h) / 2;
                const tex = wallTextures[drawTid];
                
                if (tex && tex.complete) {
                    let hitV = Math.floor((rx - rayCos * 2) / TILE) !== mx;
                    let hitX = hitV ? ry % TILE : rx % TILE;
                    let texX = Math.floor((hitX / TILE) * TEXTURE_SIZE);
                    ctx.drawImage(tex, texX, 0, 1, TEXTURE_SIZE, x, yPos, 1, h);
                }
                
                ctx.fillStyle = `rgba(0,0,0,${Math.min(0.8, dist/800)})`;
                ctx.fillRect(x, yPos, 1, h);
                break; 
            }
        }
    }
}

function getFaceIndex() {
    if (player.hp >= 100) return 0;
    if (player.hp >= 80) return 1;
    if (player.hp >= 60) return 2;
    if (player.hp >= 40) return 3;
    return 4;
}

function drawWeapon() {
    const anim = ANIMS[weapon.state];
    const sheet = anim.sheet;
    if (sheet.complete && sheet.width > 0) {
        const fw = sheet.width / anim.count;
        const fh = sheet.height;
        const dh = canvas.height * 0.7;
        const dw = dh * (fw / fh);
        ctx.save();
        ctx.translate(canvas.width * 0.25, canvas.height - 160);
        ctx.rotate(15 * Math.PI / 180);
        ctx.drawImage(sheet, anim.frames[weapon.frame] * fw, 0, fw, fh, -dw * 0.1, -dh * 0.95, dw, dh);
        ctx.restore();
    }
}

function drawHUD() {
    const top = canvas.height - 160;
    ctx.fillStyle = "#222"; ctx.fillRect(0, top, canvas.width, 160);
    ctx.fillStyle = "#000"; ctx.fillRect(40, top + 10, 85, 85);
    if (faceSheet.complete) ctx.drawImage(faceSheet, getFaceIndex()*64, 0, 64, 64, 45, top+15, 75, 75);
    ctx.fillStyle = "red"; ctx.font = "bold 16px monospace"; ctx.fillText("HEALTH", 40, top + 115);
    ctx.fillStyle = "white"; ctx.font = "bold 40px monospace"; ctx.fillText(`${player.hp}%`, 40, top + 150);
    ctx.fillStyle = "yellow"; ctx.font = "bold 16px monospace"; ctx.fillText("AMMO", canvas.width - 120, top + 40);
    ctx.fillStyle = "white"; ctx.font = "bold 30px monospace"; ctx.fillText(weapon.ammo > 0 ? "1/1" : "0/1", canvas.width - 120, top + 80);
    if (player.hasKey) { ctx.fillStyle = "gold"; ctx.font = "bold 18px monospace"; ctx.fillText("KEY OBTAINED", canvas.width/2 - 80, top + 80); }
}

function loop() {
    update();
    const vH = canvas.height - 160;
    ctx.fillStyle = "#1a1a1a"; ctx.fillRect(0, 0, canvas.width, vH/2);
    ctx.fillStyle = "#222"; ctx.fillRect(0, vH/2, canvas.width, vH/2);
    drawWalls(); drawWeapon(); drawHUD();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
